// Final Logic (Portfolio + Sharpe + MDD)
const item = $input.first();

// 1. Get Data
let apiResponse = item.json.data || item.json;
const prepareNode = $("4. Prepare Batch").first();
const originalItems = prepareNode.json.original_items; 

if (!originalItems) throw new Error("Missing original_items");

// 2. Normalize API
let sentiments = apiResponse;
if (Array.isArray(apiResponse) && Array.isArray(apiResponse[0])) sentiments = apiResponse;
else if (!Array.isArray(apiResponse)) sentiments = [apiResponse];

// 3. Setup Portfolio
const tickers = [...new Set(originalItems.map(i => i.ticker))]; 
const initialCapitalPerTicker = 10000 / tickers.length; 
const portfolio = {};

tickers.forEach(t => {
    portfolio[t] = { 
        balance: initialCapitalPerTicker, 
        coin: 0, 
        inPosition: false, 
        entryPrice: 0,
        lastEquity: initialCapitalPerTicker // Track daily equity per ticker
    };
});

// 4. Processing Loop
const trades = [];
let totalTrades = 0;
let winningTrades = 0;
let totalProfit = 0;
let totalLoss = 0;

// To track daily portfolio value, we need to know when a "day" ends.
// Assumption: Input is sorted by Date -> Ticker.
// We will collect equity snapshots.

const loopCount = Math.min(originalItems.length, sentiments.length);

for (let i = 0; i < loopCount; i++) {
    const d = originalItems[i];
    const s = sentiments[i];
    const ticker = d.ticker;
    const price = parseFloat(d.price || d.close);
    
    const wallet = portfolio[ticker];
    if (!wallet) continue;

    // --- Sentiment ---
    let best = { score: 0, label: 'NEUTRAL' };
    if (Array.isArray(s)) best = s.reduce((p, c) => (c.score > p.score ? c : p), {score: 0});
    else if (s && s.label) best = s;
    
    const sentimentLabel = best.label || 'NEUTRAL';
    const sentimentScore = best.score || 0;

    // --- Signal ---
    let decision = 'hold';
    let reason = `News: ${sentimentLabel} (${(sentimentScore*100).toFixed(0)}%)`;
    const rsi = parseFloat(d.rsi) || 50;

    if (rsi < 30) { decision = 'buy'; reason = 'Oversold'; }
    else if (rsi > 70) { decision = 'sell'; reason = 'Overbought'; }
    else {
      if (sentimentLabel === 'POSITIVE' && sentimentScore > 0.85) { decision = 'buy'; reason = 'Positive News'; }
      else if (sentimentLabel === 'NEGATIVE' && sentimentScore > 0.85) { decision = 'sell'; reason = 'Negative News'; }
    }

    // --- Execution ---
    let action = 'none';
    let pnl = 0;

    if (decision === 'buy' && !wallet.inPosition) {
        wallet.entryPrice = price;
        wallet.coin = wallet.balance / price;
        wallet.balance = 0;
        wallet.inPosition = true;
        action = 'buy';
        
    } else if (decision === 'sell' && wallet.inPosition) {
        const sellValue = wallet.coin * price;
        pnl = sellValue - (wallet.coin * wallet.entryPrice);
        
        if (pnl > 0) {
            winningTrades++;
            totalProfit += pnl;
        } else {
            totalLoss += Math.abs(pnl);
        }
        
        wallet.balance = sellValue;
        wallet.coin = 0;
        wallet.inPosition = false;
        totalTrades++;
        action = 'sell';
    }

    // --- Update Ticker Equity Snapshot ---
    // Mark to Market: Even if holding, calculate current value
    const currentTickerEquity = wallet.inPosition ? (wallet.coin * price) : wallet.balance;
    wallet.lastEquity = currentTickerEquity; 

    // Record Log
    trades.push({
        date: d.date,
        ticker: ticker,
        price: price,
        decision: decision,
        action: action,
        pnl: pnl !== 0 ? pnl.toFixed(2) : '',
        rsi,
        sentiment_label: sentimentLabel,
        sentiment_score: sentimentScore.toFixed(2),
        equity: currentTickerEquity.toFixed(2),
        reason
    });
}

// 5. Calculate Daily Portfolio Equity Curve
// Group trades by date to get the sum of ALL tickers' equity at that date.
// Problem: If a ticker doesn't trade on a date (no data?), we should use its last known equity.
// But assuming dense data (all tickers have data for all days).

const dateEquityMap = {};
const uniqueDates = [...new Set(trades.map(t => t.date))].sort();

// To be precise: For each date, sum the equity of all tickers on that date.
// The 'trades' array contains equity snapshot for that ticker on that date.
trades.forEach(t => {
    if (!dateEquityMap[t.date]) dateEquityMap[t.date] = 0;
    dateEquityMap[t.date] += parseFloat(t.equity);
});

const equityCurve = uniqueDates.map(d => dateEquityMap[d]);
// Add initial balance at start for calculation?
// Better to just use daily closes.

// 6. Calculate Metrics (Sharpe & MDD)
let peak = -Infinity;
let maxDrawdown = 0;
const dailyReturns = [];

// MDD on Portfolio Curve
for (const eq of equityCurve) {
    if (eq > peak) peak = eq;
    const dd = (peak - eq) / peak;
    if (dd > maxDrawdown) maxDrawdown = dd;
}

// Sharpe Ratio
for (let i = 1; i < equityCurve.length; i++) {
    const prev = equityCurve[i-1];
    const curr = equityCurve[i];
    const ret = prev !== 0 ? (curr - prev) / prev : 0;
    dailyReturns.push(ret);
}

const avgDailyRet = dailyReturns.reduce((a, b) => a + b, 0) / dailyReturns.length || 0;
const variance = dailyReturns.reduce((a, b) => a + Math.pow(b - avgDailyRet, 2), 0) / dailyReturns.length || 0;
const stdDev = Math.sqrt(variance);
const sharpeRatio = stdDev !== 0 ? (avgDailyRet / stdDev) * Math.sqrt(365) : 0;

// Final Stats
const finalTotalEquity = equityCurve[equityCurve.length - 1] || 10000;
const totalReturn = ((finalTotalEquity - 10000) / 10000) * 100;
const winRate = totalTrades > 0 ? ((winningTrades / totalTrades) * 100) : 0;
const profitFactor = totalLoss > 0 ? (totalProfit / totalLoss) : (totalProfit > 0 ? 999 : 0);

return [{
  json: {
    metric_summary: {
      "Total Trades": totalTrades,
      "Win Rate": winRate.toFixed(2) + "%",
      "Profit Factor": profitFactor.toFixed(2),
      "Total Return": totalReturn.toFixed(2) + "%",
      "Sharpe Ratio": sharpeRatio.toFixed(2),
      "Max Drawdown": "-" + (maxDrawdown * 100).toFixed(2) + "%",
      "Final Balance": "$" + finalTotalEquity.toFixed(2)
    },
    trade_log: trades
  }
}];
